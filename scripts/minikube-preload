#!/bin/bash
# Minikube OpenSearch Test Environment Setup Script
# Configures minikube cluster and pre-loads all required images for OpenSearch testing

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
MEMORY=${MINIKUBE_MEMORY:-7680}
CPUS=${MINIKUBE_CPUS:-4}
DISK_SIZE=${MINIKUBE_DISK:-40g}
K8S_VERSION=${MINIKUBE_K8S_VERSION:-v1.28.3}

# OpenSearch versions for testing
OPENSEARCH_IMAGES=(
    "opensearchproject/opensearch:2.9.0"
    "opensearchproject/opensearch:2.17.0"
    "opensearchproject/opensearch:3.0.0"
    "opensearchproject/opensearch-dashboards:2.9.0"
    "opensearchproject/opensearch-dashboards:2.17.0"
    "opensearchproject/opensearch-dashboards:3.0.0"
)

# Utility images commonly used in tests
UTILITY_IMAGES=(
    "busybox:latest"
    "curlimages/curl:latest"
    "nginx:alpine"
)

print_header() {
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}  ${CYAN}ğŸš€ Minikube OpenSearch Test Environment Setup${NC}                 ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

print_step() {
    echo -e "${PURPLE}â–¶${NC} $1"
}

print_success() {
    echo -e "${GREEN}âœ…${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸${NC}  $1"
}

print_error() {
    echo -e "${RED}âŒ${NC} $1"
}

print_info() {
    echo -e "${CYAN}â„¹ï¸${NC}  $1"
}

check_prerequisites() {
    print_step "Checking prerequisites..."

    # Check if minikube is installed
    if ! command -v minikube &> /dev/null; then
        print_error "minikube is not installed. Please install it first."
        echo "Visit: https://minikube.sigs.k8s.io/docs/start/"
        exit 1
    fi

    # Check if docker is installed and running
    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed. Please install Docker Desktop."
        exit 1
    fi

    if ! docker info &> /dev/null; then
        print_error "Docker is not running. Please start Docker Desktop."
        exit 1
    fi

    # Check if kubectl is installed
    if ! command -v kubectl &> /dev/null; then
        print_warning "kubectl is not installed. Installing via minikube..."
    fi

    print_success "Prerequisites check passed"
}

setup_minikube_cluster() {
    print_step "Setting up minikube cluster..."

    # Check if cluster already exists and is running
    if minikube status | grep -q "Running"; then
        print_info "Minikube cluster is already running"

        # Check resource configuration
        current_memory=$(minikube config get memory 2>/dev/null || echo "0")
        current_cpus=$(minikube config get cpus 2>/dev/null || echo "0")

        if [[ "$current_memory" -lt "$MEMORY" ]] || [[ "$current_cpus" -lt "$CPUS" ]]; then
            print_warning "Current cluster has insufficient resources (Memory: ${current_memory}MB, CPUs: ${current_cpus})"
            print_info "Recreating cluster with optimal configuration..."
            minikube delete
        else
            print_success "Cluster has sufficient resources (Memory: ${current_memory}MB, CPUs: ${current_cpus})"
            return 0
        fi
    fi

    # Create or recreate cluster with optimal settings
    print_info "Creating minikube cluster with ${MEMORY}MB RAM, ${CPUS} CPUs, ${DISK_SIZE} disk"

    minikube start \
        --memory="$MEMORY" \
        --cpus="$CPUS" \
        --disk-size="$DISK_SIZE" \
        --kubernetes-version="$K8S_VERSION" \
        --container-runtime=docker \
        --driver=docker

    print_success "Minikube cluster created successfully"
}

apply_system_optimizations() {
    print_step "Applying OpenSearch system optimizations..."

    # Enable metrics server for monitoring
    print_info "Enabling metrics server..."
    minikube addons enable metrics-server

    # Apply system optimizations for OpenSearch
    print_info "Setting vm.max_map_count for OpenSearch..."
    minikube ssh 'echo vm.max_map_count=262144 | sudo tee -a /etc/sysctl.conf' >/dev/null

    print_info "Setting inotify limits..."
    minikube ssh 'echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf' >/dev/null
    minikube ssh 'echo fs.inotify.max_user_instances=512 | sudo tee -a /etc/sysctl.conf' >/dev/null

    # Apply changes
    minikube ssh 'sudo sysctl -p' >/dev/null

    print_success "System optimizations applied"
}

preload_images() {
    print_step "Pre-loading OpenSearch images..."

    local total_images=$((${#OPENSEARCH_IMAGES[@]} + ${#UTILITY_IMAGES[@]}))
    local current=0

    echo ""
    for image in "${OPENSEARCH_IMAGES[@]}"; do
        ((current++))
        echo -e "${CYAN}[$current/$total_images]${NC} Loading OpenSearch image: ${image}"

        # Load image (minikube will pull if not cached)
        minikube image load "$image" 2>/dev/null || {
            print_warning "Failed to load $image, but continuing..."
        }
    done

    print_step "Pre-loading utility images..."
    echo ""
    for image in "${UTILITY_IMAGES[@]}"; do
        ((current++))
        echo -e "${CYAN}[$current/$total_images]${NC} Loading utility image: ${image}"

        minikube image load "$image" 2>/dev/null || {
            print_warning "Failed to load $image, but continuing..."
        }
    done

    print_success "Image pre-loading completed"
}

verify_setup() {
    print_step "Verifying cluster setup..."

    # Check node status
    if ! kubectl get nodes | grep -q "Ready"; then
        print_error "Cluster nodes are not ready"
        return 1
    fi

    # Check loaded images
    local opensearch_images_loaded=$(minikube ssh "docker images" | grep -c "opensearch" || echo "0")
    local utility_images_loaded=$(minikube ssh "docker images" | grep -E -c "(busybox|curl)" || echo "0")
    local total_images_loaded=$(minikube ssh "docker images | wc -l")

    print_success "Cluster verification passed"

    echo ""
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}  ${GREEN}ğŸ‰ Minikube OpenSearch Test Environment Ready!${NC}                 ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    # Resource summary
    print_info "Cluster Resources:"
    kubectl describe node minikube | grep -A 4 "Allocatable:" | sed 's/^/  /'
    echo ""

    # Image summary
    print_info "Loaded Images Summary:"
    echo "  â€¢ Total images loaded: $total_images_loaded"
    echo "  â€¢ OpenSearch images: $opensearch_images_loaded"
    echo "  â€¢ Utility images: $utility_images_loaded"
    echo ""

    # Show specific OpenSearch images
    print_info "Available OpenSearch Images:"
    minikube ssh "docker images" | grep "opensearch" | while read line; do
        echo "  â€¢ $line"
    done
    echo ""

    print_info "Next Steps:"
    echo "  1. Update config.yaml with optimized resource settings âœ…"
    echo "  2. Run: oko-test run playbooks/opensearch-2.9-to-2.17-upgrade.yaml"
    echo "  3. Images will load instantly from cache ğŸš€"
    echo ""

    print_info "Useful Commands:"
    echo "  â€¢ minikube dashboard          - Open Kubernetes dashboard"
    echo "  â€¢ kubectl get pods --all-namespaces - List all pods"
    echo "  â€¢ minikube ssh 'docker images' - List cached images"
    echo "  â€¢ minikube delete             - Clean up cluster"
}

show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -m, --memory MB     Set memory allocation (default: $MEMORY)"
    echo "  -c, --cpus N        Set CPU allocation (default: $CPUS)"
    echo "  -d, --disk-size GB  Set disk size (default: $DISK_SIZE)"
    echo "  -k, --k8s-version   Set Kubernetes version (default: $K8S_VERSION)"
    echo "  -h, --help          Show this help message"
    echo ""
    echo "Environment Variables:"
    echo "  MINIKUBE_MEMORY     Override memory setting"
    echo "  MINIKUBE_CPUS       Override CPU setting"
    echo "  MINIKUBE_DISK       Override disk setting"
    echo "  MINIKUBE_K8S_VERSION Override Kubernetes version"
    echo ""
    echo "Examples:"
    echo "  $0                          # Use default settings"
    echo "  $0 -m 12288 -c 6           # 12GB RAM, 6 CPUs"
    echo "  MINIKUBE_MEMORY=8192 $0    # 8GB RAM via env var"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--memory)
            MEMORY="$2"
            shift 2
            ;;
        -c|--cpus)
            CPUS="$2"
            shift 2
            ;;
        -d|--disk-size)
            DISK_SIZE="$2"
            shift 2
            ;;
        -k|--k8s-version)
            K8S_VERSION="$2"
            shift 2
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    print_header

    print_info "Configuration:"
    echo "  â€¢ Memory: ${MEMORY}MB"
    echo "  â€¢ CPUs: ${CPUS}"
    echo "  â€¢ Disk: ${DISK_SIZE}"
    echo "  â€¢ Kubernetes: ${K8S_VERSION}"
    echo ""

    check_prerequisites
    setup_minikube_cluster
    apply_system_optimizations
    preload_images
    verify_setup

    print_success "Setup completed successfully! ğŸ‰"
}

# Handle interruption gracefully
trap 'echo -e "\n${YELLOW}Setup interrupted by user${NC}"; exit 1' INT

# Run main function
main "$@"